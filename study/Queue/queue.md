# 자료구조 QUEUE
> 큐는 데이터 구조 중 하나로, 데이터를 저장하고 관리하는 기법 중 하나이다. 

> 큐는 선입선출 원칙 (FIFO, First-in First-out) 에 따라 동작하며, 가장 먼저 들어온 데이터가 가장 먼저 나가게 된다.

큐에서 Front는 원소가 제거되는 끝을 가리키며, Rear는 새로운 원소가 추가되는 끝을 가리킨다. 

![큐 사진](./../../images/queue.png)

* * * 
### 1. 배열을 사용한 큐 (arrayQueue.c)
* 배열을 사용하여 큐를 구현하는 것은 간단하지만, 큐의 최대 크기에 제한이 있으며 큐가 가득 차면 더 이상 원소를 추가할 수 없다. 
* front : 배열의 처음을 가리키는 변수로, 삭제 연산만 수행한다. 
* rear : 배열의 끝을 가리키는 변수로, 삽입 연산만 수행한다. 
> * 단점 : rear 가 MAX_QUEUE_SIZE -1이 될 경우 큐가 가득 찬 것으로 처리되기 때문에 배열의 앞부분이 비어 있더라도 큐가 가득찬 것으로 간주된다. 


### 2. 정적 배열을 이용한 환형 큐 (circularQueue.c)
* 환형 큐는 배열의 끝과 처음을 연결하여 원형으로 사용하는 큐 구현 방식이다.
> * front는 첫 번째 원소로부터 시계 방향으로 하나 앞을 가리키고, rear는 마지막 원소를 가리킨다.
> *  원소를 삽입을 할 때는 rear를 무조건 하나 증가시킨 다음, 그 위치에 원소를 삽입한다. <br>
rear = (rear +1) % MAX_QUEUE_SIZE
> * 원소를 삭제를 할 때는 먼저 front를 증가시킨 다음, 그 위치에서 데이터를 꺼낸다. <br> 
front = (front + 1) % MAX_QUEUE_SIZE
* 큐의 마지막 원소를 비워두어 front와 rear가 동일한 위치를 가리키더라도 비어 있는 상태와 가득 찬 상태를 구분할 수 있게 한다. 
> * 단점 : 환형 큐의 크기가 고정 되어 있기 때문에, 큐의 최대 용량을 초기에 설정해야 하고 큐가 가득 차면 더 이상 원소를 추가할 수 없다. 

### 3. 동적 배열을 이용한 환형 큐 (dynamicArrayQueue.c)
> * 정적 배열과는 다르게 큐가 가득 차면 동적으로 크기를 늘릴 수 있고, 큐가 비어있을 때도 크기를 축소할 수 있다. 따라서 메모리 사용을 최적화할 수 있다. 

* 동적 배열을 이용한 큐 (dynamicArrayQueue.c) 에서는 큐에서 마지막 원소를 비워두지 않고 전체를 다 채우고, 대신 구조체에 size와 capacity를 두어 큐가 꽉 찼는지 아닌지를 판별한다. 

### 4. 연결 리스트를 이용한 큐
* 연결 리스트를 이용한 큐는 동적 메모리 할당을 통해 필요한 만큼의 노드를 생성하므로 크기에 제한이 없다. 



<hr>


## 정리
> 배열 기반의 큐 : 작은 큐, 고정 크기의 큐에 적합하다. (빠른 접근이 가능함) <br> 연결리스트 기반의 큐 : 동적으로 변하는 큐에 적합하다. (배열보다 유연함)
